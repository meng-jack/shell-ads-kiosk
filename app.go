package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	"unicode"
)

type AdType string

const (
	AdTypeImage AdType = "image"
	AdTypeVideo AdType = "video"
	AdTypeHTML  AdType = "html"
)

type MediaFit string

const (
	FitContain MediaFit = "contain"
	FitCover   MediaFit = "cover"
	FitFill    MediaFit = "fill"
	FitStretch MediaFit = "stretch"
	FitCenter  MediaFit = "center"
	FitNone    MediaFit = "none"
)

type Transition struct {
	Enter string `json:"enter"`
	Exit  string `json:"exit"`
}

type AdLayout struct {
	Fit        MediaFit `json:"fit,omitempty"`
	PaddingPx  int      `json:"paddingPx,omitempty"`
	Background string   `json:"background,omitempty"`
	Width      string   `json:"width,omitempty"`
	Height     string   `json:"height,omitempty"`
}

type Ad struct {
	ID         string     `json:"id"`   // Internal identifier (generated by offsite system, not displayed)
	Name       string     `json:"name"` // User-friendly name (displayed in UI)
	Type       AdType     `json:"type"`
	DurationMs int        `json:"durationMs"`
	Src        string     `json:"src,omitempty"`
	Poster     string     `json:"poster,omitempty"`
	HTML       string     `json:"html,omitempty"`
	Transition Transition `json:"transition"`
	Layout     *AdLayout  `json:"layout,omitempty"`
}

const (
	// Server-side duration clamping (milliseconds)
	MinDurationMs     = 1150  // EXIT_ANIMATION_MS (650) + 500 margin
	MaxDurationMs     = 30000 // 30 seconds hard cap
	DefaultDurationMs = 25000 // default when not specified
)

type App struct {
	ctx             context.Context
	client          *http.Client
	playlistURL     string
	cacheDir        string
	devModeOverride *bool // Allows runtime toggling of dev mode; nil means use IS_DEV
}

func NewApp() *App {
	cacheBase, err := os.UserCacheDir()
	if err != nil || cacheBase == "" {
		cacheBase = os.TempDir()
	}
	cacheDir := filepath.Join(cacheBase, "kiosk-ads")
	_ = os.MkdirAll(cacheDir, 0o755)

	return &App{
		client:      &http.Client{Timeout: 30 * time.Second},
		playlistURL: strings.TrimSpace(os.Getenv("PLAYLIST_URL")),
		cacheDir:    cacheDir,
	}
}

func (a *App) startup(ctx context.Context) {
	a.ctx = ctx
	a.startAutoUpdate()
}

// newCacheHandler returns an http.Handler that serves locally-cached media assets
// under /cache/<filename>. It is a package-level function (not an App method) so
// that Wails does not expose it as a frontend binding.
func newCacheHandler(cacheDir string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !strings.HasPrefix(r.URL.Path, "/cache/") {
			http.NotFound(w, r)
			return
		}
		filename := filepath.Base(r.URL.Path)
		if filename == "." || filename == "/" || strings.Contains(filename, "..") {
			http.NotFound(w, r)
			return
		}
		http.ServeFile(w, r, filepath.Join(cacheDir, filename))
	})
}

// IsDevMode returns whether dev mode is enabled. Can be toggled at runtime via SetDevMode.
func (a *App) IsDevMode() bool {
	if a.devModeOverride != nil {
		return *a.devModeOverride
	}
	return IS_DEV
}

// SetDevMode allows toggling dev mode at runtime. Pass nil to revert to IS_DEV.
func (a *App) SetDevMode(enabled *bool) bool {
	a.devModeOverride = enabled
	if enabled == nil {
		return IS_DEV
	}
	return *enabled
}

// GetBuildNumber returns the build serial number (set at compile time).
func (a *App) GetBuildNumber() string {
	// BuildNumber is defined in main.go
	return BuildNumber
}

// FetchPlaylist fetches the remote playlist from PLAYLIST_URL.
// Returns an empty slice when no URL is configured or the response is empty,
// allowing the frontend to handle the fallback (Startup Shell standalone mode).
func (a *App) FetchPlaylist() ([]Ad, error) {
	if a.playlistURL == "" {
		return []Ad{}, nil
	}

	req, err := http.NewRequestWithContext(a.context(), http.MethodGet, a.playlistURL, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.Do(req)
	if err != nil {
		return []Ad{}, nil
	}
	defer resp.Body.Close()

	if resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {
		return []Ad{}, errors.New("playlist request failed: " + resp.Status)
	}

	var ads []Ad
	if err := json.NewDecoder(resp.Body).Decode(&ads); err != nil {
		return []Ad{}, err
	}

	// Sanitize and clamp the remote playlist to enforce maximum durations
	ads = sanitizeRemotePlaylist(ads)

	return ads, nil
}

// sanitizeRemotePlaylist enforces defense-in-depth on any remote playlist by
// validating types, ensuring required fields are present, sanitizing IDs, and
// clamping durations to safe bounds. Returns a new slice with only valid ads.
func sanitizeRemotePlaylist(ads []Ad) []Ad {
	out := make([]Ad, 0, len(ads))
	for _, it := range ads {
		t := string(it.Type)
		if t != string(AdTypeImage) && t != string(AdTypeVideo) && t != string(AdTypeHTML) {
			// Reject unknown types coming from external systems
			continue
		}

		// Ensure required content exists for the type
		if (it.Type == AdTypeImage || it.Type == AdTypeVideo) && strings.TrimSpace(it.Src) == "" {
			continue
		}
		if it.Type == AdTypeHTML && strings.TrimSpace(it.HTML) == "" {
			continue
		}

		// Normalize and clamp duration. External payloads cannot request an
		// infinite (0) duration — treat 0/negative as unspecified.
		dur := it.DurationMs
		if dur <= 0 {
			dur = DefaultDurationMs
		}
		if dur < MinDurationMs {
			dur = MinDurationMs
		}
		if dur > MaxDurationMs {
			dur = MaxDurationMs
		}
		it.DurationMs = dur

		// Sanitize ID and fallback name
		it.ID = sanitizeID(it.ID)
		if strings.TrimSpace(it.Name) == "" {
			it.Name = it.ID
		}

		out = append(out, it)
	}
	return out
}

// DownloadAsset downloads a remote URL to the local cache and returns a /cache/<file>
// path suitable for use as a src in the webview. If the file is already cached it is
// returned immediately. Returns an empty string (no error) if caching is unavailable.
func (a *App) DownloadAsset(adID, url string) (string, error) {
	if url == "" || a.cacheDir == "" {
		return "", nil
	}

	ext := filepath.Ext(strings.SplitN(url, "?", 2)[0])
	if ext == "" {
		ext = ".bin"
	}

	safe := sanitizeID(adID)
	destPath := filepath.Join(a.cacheDir, safe+ext)

	// Already cached – skip download.
	if _, err := os.Stat(destPath); err == nil {
		return "/cache/" + safe + ext, nil
	}

	req, err := http.NewRequestWithContext(a.context(), http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}

	resp, err := a.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("download failed: %s", resp.Status)
	}

	// Write to a temp file, then atomically rename.
	tmp, err := os.CreateTemp(a.cacheDir, "dl-*")
	if err != nil {
		return "", err
	}
	tmpName := tmp.Name()

	_, copyErr := io.Copy(tmp, resp.Body)
	tmp.Close()
	if copyErr != nil {
		os.Remove(tmpName)
		return "", copyErr
	}

	if err := os.Rename(tmpName, destPath); err != nil {
		os.Remove(tmpName)
		return "", err
	}

	return "/cache/" + safe + ext, nil
}

// CleanupAssets removes cached files whose ad ID is not in keepIDs.
func (a *App) CleanupAssets(keepIDs []string) error {
	if a.cacheDir == "" {
		return nil
	}

	keepSet := make(map[string]bool, len(keepIDs))
	for _, id := range keepIDs {
		keepSet[sanitizeID(id)] = true
	}

	entries, err := os.ReadDir(a.cacheDir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		id := strings.TrimSuffix(name, filepath.Ext(name))
		if !keepSet[id] {
			os.Remove(filepath.Join(a.cacheDir, name))
		}
	}
	return nil
}

func (a *App) context() context.Context {
	if a.ctx != nil {
		return a.ctx
	}
	return context.Background()
}

func sanitizeID(id string) string {
	var b strings.Builder
	for _, r := range id {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' || r == '_' {
			b.WriteRune(r)
		} else {
			b.WriteRune('_')
		}
	}
	return b.String()
}
