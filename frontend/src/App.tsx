import { useCallback, useEffect, useRef, useState } from "react";
import "./App.css";
import {
  CleanupAssets,
  DownloadAsset,
  FetchPlaylist,
  GetBuildNumber,
  GetPlaylistURL,
  IsDevMode,
  SetDevMode,
} from "../wailsjs/go/main/App";
import { EventsOn } from "../wailsjs/runtime/runtime";
import type { Ad, AdLayout, TransitionName } from "./types";
import type { main } from "../wailsjs/go/models";
import AdRenderer from "./components/AdRenderer";
import DevOverlay from "./components/DevOverlay";
import UpdateIndicator from "./components/UpdateIndicator";

const DEFAULT_DURATION_MS = 25000;
const EXIT_ANIMATION_MS = 650;
const PLAYLIST_REFRESH_MS = 60_000;

// ── Startup Shell section ──────────────────────────────────────────────────
// Always the first slide. When it is the only slide it runs forever (no timer).
// When external sections are present it is capped to this duration then cycles.
const STARTUP_SHELL_ID = "startup-shell-home";
const STARTUP_SHELL_DURATION_WITH_OTHERS_MS = 10_000;

/**
 * Build the full playlist that the carousel runs.
 * Startup Shell is always prepended as slide 0.
 * When externalAds is empty the result is length-1 and the carousel skips
 * all timers so the slide stays up forever.
 */
function buildPlaylist(externalAds: Ad[]): Ad[] {
  const hasOthers = externalAds.length > 0;
  const startupShell: Ad = {
    id: STARTUP_SHELL_ID,
    name: "Startup Shell",
    type: "startup-shell",
    // durationMs 0 is the sentinel for "infinite" (carousel skips timers)
    durationMs: hasOthers ? STARTUP_SHELL_DURATION_WITH_OTHERS_MS : 0,
    transition: { enter: "fade", exit: "fade" },
  };
  return [startupShell, ...externalAds];
}

const normalizeAds = (raw: unknown[]): Ad[] => {
  const result: Ad[] = [];
  raw.forEach((item, index) => {
    if (!item || typeof (item as any).type !== "string") return;
    const type = (item as any).type.toLowerCase() as string;
    if (type !== "image" && type !== "video" && type !== "html") return;

    const rawLayout = (item as any).layout;
    const layout: AdLayout | undefined = rawLayout
      ? {
          fit: rawLayout.fit || undefined,
          paddingPx: rawLayout.paddingPx || 0,
          background: rawLayout.background || undefined,
          width: rawLayout.width || undefined,
          height: rawLayout.height || undefined,
        }
      : undefined;

    // Duration clamping: enforce a sensible minimum (exit animation + margin)
    // and a hard maximum of 30s (30000 ms). If the caller explicitly sets
    // durationMs to 0 it is treated as "infinite" elsewhere (do not clamp 0).
    const rawDur = (item as any).durationMs;
    const DEFAULT = DEFAULT_DURATION_MS;
    let dur: number;
    if (typeof rawDur === "number") {
      // For external content (image/video/html) we do NOT allow an explicit
      // infinite (0) duration. Treat 0 or negative values as unspecified and
      // fall back to the default/clamped value. The Startup Shell itself uses
      // durationMs=0 as the infinite sentinel and is generated by the app,
      // not by external payloads.
      if (rawDur <= 0) {
        dur = Math.max(DEFAULT, EXIT_ANIMATION_MS + 500);
        dur = Math.min(dur, 30_000);
      } else {
        dur = Math.max(rawDur, EXIT_ANIMATION_MS + 500);
        dur = Math.min(dur, 30_000);
      }
    } else {
      dur = Math.max(DEFAULT, EXIT_ANIMATION_MS + 500);
      dur = Math.min(dur, 30_000);
    }

    result.push({
      id: (item as any).id || `ad-${index}`,
      name: (item as any).name || `Ad ${index + 1}`,
      type: type as Ad["type"],
      src: (item as any).src,
      poster: (item as any).poster,
      html: (item as any).html,
      transition: {
        enter: (item as any).transition?.enter ?? "fade",
        exit: (item as any).transition?.exit ?? "fade",
      },
      durationMs: dur,
      layout,
    });
  });
  return result;
};

function App() {
  const [ads, setAds] = useState<Ad[]>(buildPlaylist([]));
  const [activeIndex, setActiveIndex] = useState(0);
  const [isExiting, setIsExiting] = useState(false);
  const [status, setStatus] = useState("Loading playlist…");
  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);

  // Dev mode
  const [devMode, setDevMode] = useState(false);
  const [buildNumber, setBuildNumber] = useState("dev");
  const [playlistURL, setPlaylistURL] = useState("");
  const [msLeft, setMsLeft] = useState(0);
  const [updateInfo, setUpdateInfo] = useState<main.UpdateInfo | null>(null);

  // Asset caching: localSrcs is a ref so updates don't trigger mid-play re-renders.
  // activeSrc is committed once per slot change so the currently-playing ad is stable.
  const localSrcsRef = useRef<Record<string, string>>({});
  const [activeSrc, setActiveSrc] = useState<string | undefined>(undefined);

  const exitTimer = useRef<number>();
  const advanceTimer = useRef<number>();
  const slotStartRef = useRef(Date.now());

  // ── One-time init ──────────────────────────────────────────────────────────
  useEffect(() => {
    Promise.all([IsDevMode(), GetBuildNumber(), GetPlaylistURL()])
      .then(([isDev, build, url]) => {
        setDevMode(isDev);
        setBuildNumber(build);
        setPlaylistURL(url);
      })
      .catch(() => {
        // Fallback: treat Vite dev server as dev mode
        setDevMode(import.meta.env.DEV);
      });

    // Listen for the background updater events (emitted from updater.go).
    const unsubAvailable = EventsOn(
      "update:available",
      (info: main.UpdateInfo) => {
        setUpdateInfo(info);
      },
    );
    const unsubError = EventsOn("update:error", (msg: string) => {
      console.warn("[updater] error:", msg);
    });

    return () => {
      unsubAvailable();
      unsubError();
    };
  }, []);

  // ── Asset download helper (fire-and-forget) ────────────────────────────────
  const downloadAssetsInBackground = useCallback((loadedAds: Ad[]) => {
    const targets = loadedAds.filter(
      (ad) => ad.src && (ad.type === "image" || ad.type === "video"),
    );

    Promise.allSettled(
      targets.map(async (ad) => {
        try {
          const local = await DownloadAsset(ad.id, ad.src!);
          if (local) {
            localSrcsRef.current[ad.id] = local;
          }
        } catch {
          /* ignore individual download failures */
        }
      }),
    ).then(() => {
      // After all downloads attempted, purge stale cache entries.
      CleanupAssets(loadedAds.map((a) => a.id)).catch(() => {});
    });
  }, []);

  // ── Playlist refresh loop ──────────────────────────────────────────────────
  const refreshPlaylist = useCallback(async () => {
    try {
      const payload = await FetchPlaylist();
      const external =
        Array.isArray(payload) && payload.length ? normalizeAds(payload) : [];
      const full = buildPlaylist(external);
      setAds(full);
      setActiveIndex(0);
      if (external.length > 0) {
        setStatus("Playing live playlist");
        setLastRefresh(new Date());
        downloadAssetsInBackground(external);
      } else {
        setStatus("Startup Shell — standalone mode");
      }
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      console.error("[playlist] fetch failed:", msg);
      setStatus(`Fetch error: ${msg}`);
      setAds(buildPlaylist([]));
    }
  }, [downloadAssetsInBackground]);

  useEffect(() => {
    refreshPlaylist();
    const id = window.setInterval(refreshPlaylist, PLAYLIST_REFRESH_MS);
    return () => window.clearInterval(id);
  }, [refreshPlaylist]);

  // ── Carousel advance ───────────────────────────────────────────────────────
  useEffect(() => {
    window.clearTimeout(exitTimer.current);
    window.clearTimeout(advanceTimer.current);

    if (!ads.length) return;

    // Single-slide mode: Startup Shell alone — show forever, no timers.
    if (ads.length === 1) {
      setIsExiting(false);
      slotStartRef.current = Date.now();
      setActiveSrc(undefined);
      return;
    }

    setIsExiting(false);
    slotStartRef.current = Date.now();

    const ad = ads[activeIndex % ads.length];
    const duration = ad.durationMs ?? DEFAULT_DURATION_MS;

    // Lock in the src for this slot (local cache if ready, otherwise remote).
    setActiveSrc(localSrcsRef.current[ad.id] ?? ad.src);

    exitTimer.current = window.setTimeout(
      () => setIsExiting(true),
      Math.max(duration - EXIT_ANIMATION_MS, 500),
    );
    advanceTimer.current = window.setTimeout(
      () => setActiveIndex((i) => (i + 1) % ads.length),
      duration,
    );

    return () => {
      window.clearTimeout(exitTimer.current);
      window.clearTimeout(advanceTimer.current);
    };
  }, [ads, activeIndex]);

  // ── Dev-mode keyboard navigation (← prev, → next, D: toggle dev mode) ──────
  // Immediately cancels the running timers and jumps to the adjacent ad with a
  // short exit flash so the transition still plays.
  const navigate = useCallback(
    (delta: 1 | -1) => {
      if (!ads.length) return;
      window.clearTimeout(exitTimer.current);
      window.clearTimeout(advanceTimer.current);
      setIsExiting(true);
      advanceTimer.current = window.setTimeout(() => {
        setActiveIndex((i) => (i + delta + ads.length) % ads.length);
      }, EXIT_ANIMATION_MS);
    },
    [ads.length],
  );

  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const key = e.key.toLowerCase();

      // Z — activate all pending ads from the launcher (works in any mode)
      if (key === "z") {
        e.preventDefault();
        fetch("http://localhost:6969/api/activate", { method: "POST" })
          .then(() => refreshPlaylist())
          .catch(() => refreshPlaylist()); // still refresh even if launcher unreachable
        return;
      }

      if (key === "d") {
        e.preventDefault();
        SetDevMode(!devMode)
          .then((newState: boolean) => setDevMode(newState))
          .catch(() => {});
        return;
      }
      if (!devMode) return;
      if (e.key === "ArrowRight") navigate(1);
      if (e.key === "ArrowLeft") navigate(-1);
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [devMode, navigate, refreshPlaylist]);

  // ── Dev-mode countdown ticker ──────────────────────────────────────────────
  useEffect(() => {
    if (!devMode || !ads.length) return;
    const id = window.setInterval(() => {
      const dur =
        ads[activeIndex % ads.length]?.durationMs ?? DEFAULT_DURATION_MS;
      setMsLeft(Math.max(0, dur - (Date.now() - slotStartRef.current)));
    }, 100);
    return () => window.clearInterval(id);
  }, [devMode, ads, activeIndex]);

  const activeAd = ads.length ? ads[activeIndex % ads.length] : undefined;
  const enterName: TransitionName = activeAd?.transition?.enter ?? "fade";
  const exitName: TransitionName = activeAd?.transition?.exit ?? "fade";
  // When Startup Shell is the only slide there is nothing to transition to/from.
  const isAlone = ads.length === 1;

  return (
    <div className="app-shell">
      <div className="ad-viewport">
        {activeAd ? (
          <div
            key={`${activeAd.id}-${activeIndex}`}
            className={
              isAlone
                ? "ad-card"
                : `ad-card enter-${enterName} ${isExiting ? `exit-${exitName}` : ""}`.trim()
            }
          >
            <AdRenderer ad={activeAd} overrideSrc={activeSrc} />
          </div>
        ) : (
          <div className="placeholder">Waiting for playlist…</div>
        )}
      </div>

      {devMode && activeAd && (
        <>
          <DevOverlay
            ad={activeAd}
            index={activeIndex % ads.length}
            total={ads.length}
            msLeft={msLeft}
            status={status}
            lastRefresh={lastRefresh}
            isExiting={isExiting}
            isCached={Boolean(localSrcsRef.current[activeAd.id])}
            activeSrc={activeSrc}
            buildNumber={buildNumber}
            playlistURL={playlistURL}
            updateInfo={updateInfo}
          />
          <div className="status-bar">
            <span className="status-text">{status}</span>
            <span className="status-count">
              {ads.length
                ? `${(activeIndex % ads.length) + 1} / ${ads.length}`
                : "0 / 0"}
            </span>
          </div>
        </>
      )}
      <UpdateIndicator updateInfo={updateInfo} devMode={devMode} />
    </div>
  );
}

export default App;
