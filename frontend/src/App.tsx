import { useCallback, useEffect, useRef, useState } from "react";
import "./App.css";
import {
  CleanupAssets,
  DownloadAsset,
  FetchPlaylist,
  GetBuildNumber,
  GetPlaylistURL,
  IsDevMode,
  SetDevMode,
} from "../wailsjs/go/main/App";
import { EventsOn } from "../wailsjs/runtime/runtime";
import type { Ad, AdLayout, TransitionName } from "./types";
import type { main } from "../wailsjs/go/models";
import AdRenderer from "./components/AdRenderer";
import DevOverlay from "./components/DevOverlay";
import UpdateIndicator from "./components/UpdateIndicator";

const DEFAULT_DURATION_MS = 25000;
const EXIT_ANIMATION_MS = 650;
const PLAYLIST_REFRESH_MS = 60_000;

// ── Startup Shell section ──────────────────────────────────────────────────
// Always the first slide. When it is the only slide it runs forever (no timer).
// When external sections are present it is capped to this duration then cycles.
const STARTUP_SHELL_ID = "startup-shell-home";
const STARTUP_SHELL_DURATION_WITH_OTHERS_MS = 10_000;

/**
 * Build the full playlist that the carousel runs.
 * Startup Shell is always prepended as slide 0.
 * When externalAds is empty the result is length-1 and the carousel skips
 * all timers so the slide stays up forever.
 */
function buildPlaylist(externalAds: Ad[]): Ad[] {
  const hasOthers = externalAds.length > 0;
  const startupShell: Ad = {
    id: STARTUP_SHELL_ID,
    name: "Startup Shell",
    type: "startup-shell",
    // durationMs 0 is the sentinel for "infinite" (carousel skips timers)
    durationMs: hasOthers ? STARTUP_SHELL_DURATION_WITH_OTHERS_MS : 0,
    transition: { enter: "fade", exit: "fade" },
  };
  return [startupShell, ...externalAds];
}

const normalizeAds = (raw: unknown[]): Ad[] => {
  const result: Ad[] = [];
  raw.forEach((item, index) => {
    if (!item || typeof (item as any).type !== "string") return;
    const type = (item as any).type.toLowerCase() as string;
    if (type !== "image" && type !== "video" && type !== "html") return;

    const rawLayout = (item as any).layout;
    const layout: AdLayout | undefined = rawLayout
      ? {
          fit: rawLayout.fit || undefined,
          paddingPx: rawLayout.paddingPx || 0,
          background: rawLayout.background || undefined,
          width: rawLayout.width || undefined,
          height: rawLayout.height || undefined,
        }
      : undefined;

    // Duration clamping: enforce a sensible minimum (exit animation + margin)
    // and a hard maximum of 30s (30000 ms). If the caller explicitly sets
    // durationMs to 0 it is treated as "infinite" elsewhere (do not clamp 0).
    const rawDur = (item as any).durationMs;
    const DEFAULT = DEFAULT_DURATION_MS;
    let dur: number;
    if (typeof rawDur === "number") {
      // For external content (image/video/html) we do NOT allow an explicit
      // infinite (0) duration. Treat 0 or negative values as unspecified and
      // fall back to the default/clamped value. The Startup Shell itself uses
      // durationMs=0 as the infinite sentinel and is generated by the app,
      // not by external payloads.
      if (rawDur <= 0) {
        dur = Math.max(DEFAULT, EXIT_ANIMATION_MS + 500);
        dur = Math.min(dur, 30_000);
      } else {
        dur = Math.max(rawDur, EXIT_ANIMATION_MS + 500);
        dur = Math.min(dur, 30_000);
      }
    } else {
      dur = Math.max(DEFAULT, EXIT_ANIMATION_MS + 500);
      dur = Math.min(dur, 30_000);
    }

    result.push({
      id: (item as any).id || `ad-${index}`,
      name: (item as any).name || `Ad ${index + 1}`,
      type: type as Ad["type"],
      src: (item as any).src,
      poster: (item as any).poster,
      html: (item as any).html,
      transition: {
        enter: (item as any).transition?.enter ?? "fade",
        exit: (item as any).transition?.exit ?? "fade",
      },
      durationMs: dur,
      layout,
    });
  });
  return result;
};

function App() {
  const [ads, setAds] = useState<Ad[]>(buildPlaylist([]));
  const [activeIndex, setActiveIndex] = useState(0);
  const [isExiting, setIsExiting] = useState(false);
  const [status, setStatus] = useState("Loading playlist…");
  const [lastRefresh, setLastRefresh] = useState<Date | null>(null);

  // Dev mode
  const [devMode, setDevMode] = useState(false);
  const [buildNumber, setBuildNumber] = useState("dev");
  const [playlistURL, setPlaylistURL] = useState("");
  const [msLeft, setMsLeft] = useState(0);
  const [updateInfo, setUpdateInfo] = useState<main.UpdateInfo | null>(null);

  // Asset caching: localSrcs is a ref so updates don't trigger mid-play re-renders.
  // activeSrc is committed once per slot change so the currently-playing ad is stable.
  const localSrcsRef = useRef<Record<string, string>>({});
  const [activeSrc, setActiveSrc] = useState<string | undefined>(undefined);

  const exitTimer = useRef<number>();
  const advanceTimer = useRef<number>();
  const slotStartRef = useRef(Date.now());

  // ── One-time init ──────────────────────────────────────────────────────────
  useEffect(() => {
    Promise.all([IsDevMode(), GetBuildNumber(), GetPlaylistURL()])
      .then(([isDev, build, url]) => {
        setDevMode(isDev);
        setBuildNumber(build);
        setPlaylistURL(url);
      })
      .catch(() => {
        // Fallback: treat Vite dev server as dev mode
        setDevMode(import.meta.env.DEV);
      });

    // Listen for the background updater events (emitted from updater.go).
    const unsubAvailable = EventsOn(
      "update:available",
      (info: main.UpdateInfo) => {
        setUpdateInfo(info);
      },
    );
    const unsubError = EventsOn("update:error", (msg: string) => {
      console.warn("[updater] error:", msg);
    });

    return () => {
      unsubAvailable();
      unsubError();
    };
  }, []);

  // ── Asset download + playlist swap ────────────────────────────────────────
  // Guard against concurrent refreshes (e.g. 60 s timer firing while a Z-key
  // triggered refresh is still downloading).
  const refreshingRef = useRef(false);

  const refreshPlaylist = useCallback(async () => {
    if (refreshingRef.current) return;
    refreshingRef.current = true;
    try {
      const payload = await FetchPlaylist();
      const external =
        Array.isArray(payload) && payload.length ? normalizeAds(payload) : [];

      if (external.length === 0) {
        setAds(buildPlaylist([]));
        setStatus("Startup Shell — standalone mode");
        return;
      }

      // ── Download phase ───────────────────────────────────────────────────
      // Keep the currently playing playlist unchanged while we pull every
      // image and video asset to the local cache/ folder.  HTML URL ads need
      // no download — they stream into a native iframe at play-time.
      setStatus(`Downloading ${external.length} ad(s)…`);

      await Promise.allSettled(
        external
          .filter(
            (ad) => ad.src && (ad.type === "image" || ad.type === "video"),
          )
          .map(async (ad) => {
            try {
              const local = await DownloadAsset(ad.id, ad.src!);
              if (local) localSrcsRef.current[ad.id] = local;
            } catch {
              /* individual download failure — will fall back to remote src */
            }
          }),
      );

      // ── Swap phase ───────────────────────────────────────────────────────
      // All downloads finished (success or fail).  Now atomically swap the
      // playlist so every slot starts with a cached local path already in
      // localSrcsRef — no blank frames, no remote-URL race.
      const full = buildPlaylist(external);
      setAds(full);
      setActiveIndex(0);
      setStatus("Playing live playlist");
      setLastRefresh(new Date());

      // Purge cache entries that are no longer in the playlist.
      CleanupAssets(external.map((a) => a.id)).catch(() => {});
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      console.error("[playlist] fetch failed:", msg);
      setStatus(`Fetch error: ${msg}`);
      setAds(buildPlaylist([]));
    } finally {
      refreshingRef.current = false;
    }
  }, []);

  useEffect(() => {
    refreshPlaylist();
    const id = window.setInterval(refreshPlaylist, PLAYLIST_REFRESH_MS);
    return () => window.clearInterval(id);
  }, [refreshPlaylist]);

  // ── Carousel advance ───────────────────────────────────────────────────────
  useEffect(() => {
    window.clearTimeout(exitTimer.current);
    window.clearTimeout(advanceTimer.current);

    if (!ads.length) return;

    // Single-slide mode: Startup Shell alone — show forever, no timers.
    if (ads.length === 1) {
      setIsExiting(false);
      slotStartRef.current = Date.now();
      setActiveSrc(undefined);
      return;
    }

    setIsExiting(false);
    slotStartRef.current = Date.now();

    const ad = ads[activeIndex % ads.length];
    const duration = ad.durationMs ?? DEFAULT_DURATION_MS;

    // Lock in the src for this slot (local cache if ready, otherwise remote).
    setActiveSrc(localSrcsRef.current[ad.id] ?? ad.src);

    exitTimer.current = window.setTimeout(
      () => setIsExiting(true),
      Math.max(duration - EXIT_ANIMATION_MS, 500),
    );
    advanceTimer.current = window.setTimeout(
      () => setActiveIndex((i) => (i + 1) % ads.length),
      duration,
    );

    return () => {
      window.clearTimeout(exitTimer.current);
      window.clearTimeout(advanceTimer.current);
    };
  }, [ads, activeIndex]);

  // ── Report shown ads to the launcher ──────────────────────────────────────
  // When an ad becomes active the launcher marks it so the submitter can see
  // "Shown on screen" in their dashboard. Only fires for real submitted ads.
  useEffect(() => {
    if (!ads.length) return;
    const ad = ads[activeIndex];
    if (!ad?.id) return;
    fetch("http://localhost:6969/api/kiosk/report-shown", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: ad.id }),
    }).catch(() => {}); // silent — launcher may not be running
  }, [ads, activeIndex]);

  // ── Report current ad to launcher ─────────────────────────────────────────
  // Notify launcher which ad is currently playing for admin preview metadata
  useEffect(() => {
    if (!ads.length) return;
    const ad = ads[activeIndex];
    fetch("http://localhost:6969/api/kiosk/current-ad", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id: ad?.id || "" }),
    }).catch(() => {});
  }, [ads, activeIndex]);

  // ── Screenshot capture for admin preview ──────────────────────────────────
  // Captures a 640×360 thumbnail of whatever is currently playing and sends it
  // to the launcher every 3 s.  All ad types are handled:
  //   • startup-shell → faithfully drawn on canvas (no DOM capture needed)
  //   • image / video  → drawImage from the live element
  //   • html           → branded placeholder
  useEffect(() => {
    const W = 640,
      H = 360;

    function txt(
      ctx: CanvasRenderingContext2D,
      t: string,
      x: number,
      y: number,
      size: number,
      weight: string,
      alpha: number,
    ) {
      ctx.save();
      ctx.font = `${weight} ${size}px "Nunito", sans-serif`;
      ctx.fillStyle = `rgba(251,245,243,${alpha})`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(t, x, y);
      ctx.restore();
    }

    const captureScreenshot = () => {
      const canvas = document.createElement("canvas");
      canvas.width = W;
      canvas.height = H;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const ad = ads.length ? ads[activeIndex % ads.length] : undefined;

      if (!ad || ad.type === "startup-shell") {
        // ── Startup Shell: programmatic canvas copy ──────────────────────
        ctx.fillStyle = "#d74034";
        ctx.fillRect(0, 0, W, H);
        const vig = ctx.createRadialGradient(
          W / 2,
          H / 2,
          W * 0.15,
          W / 2,
          H / 2,
          W * 0.72,
        );
        vig.addColorStop(0, "transparent");
        vig.addColorStop(1, "rgba(0,0,0,0.28)");
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, W, H);

        txt(ctx, "Startup Shell", W / 2, H / 2 - 36, 52, "800", 1.0);

        ctx.save();
        ctx.strokeStyle = "rgba(251,245,243,0.22)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(W / 2 - 70, H / 2 - 6);
        ctx.lineTo(W / 2 + 70, H / 2 - 6);
        ctx.stroke();
        ctx.restore();

        txt(
          ctx,
          "UMD's Home for Creators & Entrepreneurs",
          W / 2,
          H / 2 + 16,
          13,
          "400",
          0.78,
        );

        const stats: [string, string][] = [
          ["600+", "Members"],
          ["300+", "Ventures"],
          ["$2B+", "Venture Value"],
        ];
        stats.forEach(([num, label], i) => {
          const sx = W / 2 + (i - 1) * 104;
          txt(ctx, num, sx, H / 2 + 62, 18, "800", 0.95);
          txt(ctx, label, sx, H / 2 + 82, 10, "700", 0.5);
        });
      } else if (ad.type === "image" || ad.type === "video") {
        // ── Media: capture the live element ──────────────────────────────
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);
        const viewport = document.querySelector(
          ".ad-viewport",
        ) as HTMLElement | null;
        const el = viewport?.querySelector("img, video") as
          | HTMLImageElement
          | HTMLVideoElement
          | null;
        if (el) {
          try {
            if (
              el instanceof HTMLImageElement &&
              el.complete &&
              el.naturalWidth > 0
            )
              ctx.drawImage(el, 0, 0, W, H);
            else if (el instanceof HTMLVideoElement && el.readyState >= 2)
              ctx.drawImage(el, 0, 0, W, H);
          } catch {
            /* tainted canvas / CORS — leave black */
          }
        }
      } else {
        // ── HTML ad: branded placeholder ─────────────────────────────────
        ctx.fillStyle = "#1a0a08";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "rgba(215,64,52,0.25)";
        ctx.fillRect(0, 0, W, H);
        txt(ctx, ad.name || "HTML Ad", W / 2, H / 2 - 10, 18, "700", 0.7);
        txt(ctx, "HTML content", W / 2, H / 2 + 12, 12, "600", 0.35);
      }

      canvas.toBlob(
        async (blob) => {
          if (!blob) return;
          try {
            await fetch("http://localhost:6969/api/kiosk/screenshot", {
              method: "POST",
              headers: { "Content-Type": "image/jpeg" },
              body: blob,
            });
          } catch {
            /* launcher unreachable */
          }
        },
        "image/jpeg",
        0.82,
      );
    };

    const interval = setInterval(captureScreenshot, 4000);
    const initial = setTimeout(captureScreenshot, 800);
    return () => {
      clearInterval(interval);
      clearTimeout(initial);
    };
  }, [ads, activeIndex]);

  // ── Dev-mode keyboard navigation (← prev, → next, D: toggle dev mode) ──────
  // Immediately cancels the running timers and jumps to the adjacent ad with a
  // short exit flash so the transition still plays.
  const navigate = useCallback(
    (delta: 1 | -1) => {
      if (!ads.length) return;
      window.clearTimeout(exitTimer.current);
      window.clearTimeout(advanceTimer.current);
      setIsExiting(true);
      advanceTimer.current = window.setTimeout(() => {
        setActiveIndex((i) => (i + delta + ads.length) % ads.length);
      }, EXIT_ANIMATION_MS);
    },
    [ads.length],
  );

  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const key = e.key.toLowerCase();

      // Z — activate all pending ads from the launcher (works in any mode)
      if (key === "z") {
        e.preventDefault();
        fetch("http://localhost:6969/api/activate", { method: "POST" })
          .then(() => refreshPlaylist())
          .catch(() => refreshPlaylist());
        return;
      }

      if (key === "d") {
        e.preventDefault();
        SetDevMode(!devMode)
          .then((newState: boolean) => setDevMode(newState))
          .catch(() => {});
        return;
      }
      if (!devMode) return;
      if (e.key === "ArrowRight") navigate(1);
      if (e.key === "ArrowLeft") navigate(-1);
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [devMode, navigate, refreshPlaylist]);

  // ── Remote nav poll (admin dashboard ← → buttons) ─────────────────────────
  // Long-polls the launcher every ~2 s. When the admin presses next/prev the
  // launcher queues a command and the next poll picks it up immediately.
  useEffect(() => {
    let cancelled = false;

    async function poll() {
      while (!cancelled) {
        try {
          const res = await fetch("http://localhost:6969/api/kiosk/nav-poll");
          if (!cancelled && res.ok) {
            const { cmd } = (await res.json()) as { cmd: string };
            if (cmd === "next") navigate(1);
            else if (cmd === "prev") navigate(-1);
          }
        } catch {
          // Launcher unreachable — wait a bit before retrying
          await new Promise((r) => window.setTimeout(r, 2000));
        }
      }
    }

    poll();
    return () => {
      cancelled = true;
    };
  }, [navigate]);

  // ── Dev-mode countdown ticker ──────────────────────────────────────────────
  useEffect(() => {
    if (!devMode || !ads.length) return;
    const id = window.setInterval(() => {
      const dur =
        ads[activeIndex % ads.length]?.durationMs ?? DEFAULT_DURATION_MS;
      setMsLeft(Math.max(0, dur - (Date.now() - slotStartRef.current)));
    }, 100);
    return () => window.clearInterval(id);
  }, [devMode, ads, activeIndex]);

  const activeAd = ads.length ? ads[activeIndex % ads.length] : undefined;
  const enterName: TransitionName = activeAd?.transition?.enter ?? "fade";
  const exitName: TransitionName = activeAd?.transition?.exit ?? "fade";
  // When Startup Shell is the only slide there is nothing to transition to/from.
  const isAlone = ads.length === 1;

  return (
    <div className="app-shell">
      <div className="ad-viewport">
        {activeAd ? (
          <div
            key={`${activeAd.id}-${activeIndex}`}
            className={
              isAlone
                ? "ad-card"
                : `ad-card enter-${enterName} ${isExiting ? `exit-${exitName}` : ""}`.trim()
            }
          >
            <AdRenderer ad={activeAd} overrideSrc={activeSrc} />
          </div>
        ) : (
          <div className="placeholder">Waiting for playlist…</div>
        )}
      </div>

      {devMode && activeAd && (
        <>
          <DevOverlay
            ad={activeAd}
            index={activeIndex % ads.length}
            total={ads.length}
            msLeft={msLeft}
            status={status}
            lastRefresh={lastRefresh}
            isExiting={isExiting}
            isCached={Boolean(localSrcsRef.current[activeAd.id])}
            activeSrc={activeSrc}
            buildNumber={buildNumber}
            playlistURL={playlistURL}
            updateInfo={updateInfo}
          />
          <div className="status-bar">
            <span className="status-text">{status}</span>
            <span className="status-count">
              {ads.length
                ? `${(activeIndex % ads.length) + 1} / ${ads.length}`
                : "0 / 0"}
            </span>
          </div>
        </>
      )}
      <UpdateIndicator updateInfo={updateInfo} devMode={devMode} />
    </div>
  );
}

export default App;
